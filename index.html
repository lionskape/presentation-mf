<!doctype html>
<html lang="ru">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/league.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

		<style>
			:root {
				--r-main-font-size: 20px;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Изменения в структуре фронтенда для Altium</section>
				<section>
					<h4>Цели:</h4>
					<ul>
						<li>Упростить onboarding новых разработчиков</li>
						<li>Унифицировать версии зависимостей</li>
						<li>Упростить добавление новых пакетов</li>
						<li>Ускорить загрузку страницы у пользователей</li>
						<li>Переиспользовать логику между A365, Viewer, etc</li>
					</ul>
				</section>
				<section>
					<section>Упростить OnBoarding новых разработчиков</section>
					<section>
						<h4>Зачем?</h4>
						<ul>
							<li>Уменьшить трудозатраты по OnBoarding процессу</li>
							<li>Получить более качественный код</li>
							<li>Уменьшить порог входа в кодовую базу</li>
							<li>Уменьшить время от первого дня до первого коммита</li>
						</ul>
					</section>
					<section>
						<h4>Как?</h4>
					</section>
					<section>
						<h4>Сложить весь фронтенд в одну дирректорию <small>(в старых местах оставить симлинки)</small></h4>
						<ul>
							<li>Меньше путаницы в дирректориях (не нужно запоминать пути, переходить куда попало)</li>
							<li>Проще настраивать редактор (достаточно выбрать для индексации одну единственную дирректорию)</li>
							<li>Не видишь "лишние" куски, которые все равно не запускаешь</li>
							<li>Проще проверить какие подходы, технологии приняты в проекте</li>
						</ul>
					</section>
					<section>
						<h4>Одна точка входа для документации</h4>
						<p>Вместо разбросанной документации по проекту сложить всё в одну дирректорию.</p>
						<ul>
							<li>Проще искать нужную статью</li>
							<li>Проще искать только по документации</li>
							<li>Возможность структурировать документацию</li>
							<li>Возможность явным образом создавать общие для всего проекта документы</li>
							<li>Это не отменяет возможности в документации ставить ссылки на файлы в отдельных пакетах</li>
						</ul>
					</section>
					<section>
						<h4>Использовать хуки для форматирования \ линтинга (lefthook)</h4>
						<ul>
							<li>Позволит отказаться от форматирования при сборке <br><small>Код перестанет моргать, лиди перестанут терять изменения</small></li>
							<li>Позволит автоматически формировать шаблон текста коммита (в т.ч. для мердж коммитов) в зависимости от имени ветки<br>Это сильно уменьшит количество проблемм при пушах</li>
							<li><small>Теоретически возможности локальной автоматизации безграничны</small></li>
						</ul>
					</section>
					<section>
						<h4>Добавить пайплайн для проверки форматирования и линтинга</h4>
						<p>Проверка будет происходить локально, но ее можно пропустить. Необходима гарантия, но проверять ее при пуше нет смысла. Синтаксис pre-receive хука беден, нет инструментария. Гораздо проще и удобнее декларативно описать автозапускающийся пайплайн.</p>
						<ul>
							<li>Позволит гарантировать то, что разработчик не запушит плохо форматированный, и ему не придется его переделывать</li>
							<li>Этот пайплайн не будет мешать новичкам, поскольку будет отрабатывать асинхронно, и они не будут пропускать хуки гита</li>
						</ul>
					</section>
					<section>
						<h4>Результат</h4>
						<ul>
							<li>Систематизация кода</li>
							<li>Упрощение чтения документации</li>
							<li>Упрощение анализа кода, реверс инжениринга</li>
						</ul>
					</section>
					<section>
						<h4>Риски</h4>
						<ul>
							<li>Есть очень маленькая вероятность, что некоторые части системы не будут корректно обрабатывать симлинки</li>
							<li>Для старых разработчиков с очень маленькой вероятностью может потребоваться небольшое количество времени для перенастройки IDE</li>
						</ul>
					</section>
				</section>
				<section>
					<section>Унифицировать версии зависимостей</section>
					<section>
						<h4>Зачем?</h4>
						<ul>
							<li>Избежать ситуаций, в которых при переиспользовании одной зависимости баг воспроизводится не во всех модулях</li>
							<li>Централизованное обновление пакетов позволит единовременно доставляить исправление ошибок / уязвимостей во все приложения</li>
							<li>Избежать ситуаций, при которых разработчикам нужно задумываться о том доступна ли определенная "фича" в каком-то конкретном приложении</li>
							<li>Возможность переиспользоваться зависимости между разными приложениями, например загружать Vue \ Vuex только один раз для Viewer + A365.</li>
							<li>Возможность работать с peer зависимостями \ прямыми зависимостями, вместо работы с глобальными переменными</li>
						</ul>
					</section>
					<section>
						<h4>Как?</h4>
					</section>
					<section>
						<h4>Перейти на использование менеджера монорепозиториев (e.g. lerna)</h4>
						<ul>
							<li>Возможность централизованного обновления зависимостей</li>
							<li>Возможность централизованной установки и хойстинга зависимостей</li>
							<li>(Бонус) Благодаря хойстингу IDE нужно будет меньше индексировать, как следствие более быстрая работа</li>
							<li>(Бонус) Благодаря хойстингу проект с зависимостями будет весить меньше</li>
							<li>(Бонус) Возможность в одну комманду запустить все (или группу / отдельные) UI приложения и пробросить в них единообразный конфиг бэкенда</li>
						</ul>
					</section>
					<section>
						<h4>Реализовать gitlab пайплайн проверяющий появление новых расхождений</h4>
						<ul>
							<li>Он не зависит от остальных шагов, как следствие может работать параллельно с остальными не замедляя процесс CI\CD</li>
							<li>Пайплайн должен блокировать мердж при добавлении новых расхождений (до явного аппрува изменений со стороны комманды)</li>
						</ul>
					</section>
					<section>
						<h4>Перейти на использование `npm ci` вместо `npm i`, разблокировать semver патчи</h4>
						<ul>
							<li>`npm ci` гарантирует идемпотентность сборки</li>
							<li>разблокировка semver патчей позволит легко и централизованно обновлять патч-версию повышая безопасность системы</li>
						</ul>
					</section>
					<section>
						<h4>Результат</h4>
						<ul>
							<li>Менеджер монорепозитория указывает проблемы с версиями зависимостей</li>
							<li>Информация о том, какие пакеты существуют, как их запускать - централизована</li>
							<li>Версии пакетов одинаковы, что позволяет их переиспользовать (в теории)</li>
							<li>Обновление версией пакетов происходит одновременно для всех приложений</li>
							<li>Если понадобится - возможно настроить сквозное версионирование локальных пакетов (возможно в будущем)</li>
							<li>При открытии возможности для внешних разработчиков плагинов - набор переиспользуемых компонентов можно предоставить как peer зависимость</li>
						</ul>
					</section>
					<section>
						<h4>Риски</h4>
						<ul>
							<li>Необходимо выполнить централизацию фронтенда, в противном случае настройка, отладка и использование могут стать не удобными</li>
							<li>Переход на npm ci может быть не очевидным процессом, мейкмастер как вегас. Что происходит в мейкмастере - остается в мейкмастере.</li>
						</ul>
					</section>
				</section>
				<section>
					<section>Упростить добавление пакетов</section>
					<section>
						<h4>Зачем?</h4>
						<ul>
							<li>Локальные пакеты намного проще использовать и могуть быть разделяемыми частями (в отличии от текущего подхода с импортом исходного кода)</li>
							<li>Использование пакета как переиспользуемую часть (например между viewer и a365) позволит остановить бесконечный рост component, и даже облегчить его</li>
							<li>Простота добавления пакетов позволит без проблем организовать такие вещи как переиспользуемый конфиг eslint и т.п.</li>
						</ul>
					</section>
					<section><h4>Как?</h4></section>
					<section>
						<h4>Перейти на менеджер монорепозиториев (lerna)</h4>
						<ul>
							<li>Позволит вместо npm link использовать автоматическую линковку предоставляемую lerna</li>
							<li>Позволит глядя на конфиг легко понять где и какие у нас есть пакеты</li>
						</ul>
					</section>
					<section>
						<h4>Описать какие причины могут быть для добавления нового пакета, как добавить причину в этот список</h4>
						<small>Сделать процесс аналогичный добавлению новых зависимостей</small>
						<ul>
							<li>Упростит контроль за ростом количества зависимостей</li>
							<li>Предоставит понятный механизм для расширения поведения</li>
						</ul>
					</section>
					<section>
						<h4>Результаты</h4>
						<ul>
							<li>Систематизация способов добавления изолированной логики в код</li>
							<li>Упрощение переиспользования кода между приложениями</li>
						</ul>
					</section>
					<section>
						<h4>Риски</h4>
						<ul>
							<li>Старые разработчики могут достаточно долго адаптироваться к новымпроцессам</li>
							<li>Не может быть имплементировано частично</li>
						</ul>
					</section>
				</section>
				<section>
					<section><h4>Ускорить загрузку страницы у пользователей</h4></section>
					<section>
						<h4>Зачем?</h4>
						<ul>
							<li>Зачастую ускорение загрузки позитивно влияет на пользовательский опыт</li>
							<li>Более быстрая загрузка интерфейса так же положительно влияет на производительность работы UI разработчиков и тестировщиков</li>
							<li>Железо будет меньше потреблять энергии, ледники будут таять медленнее</li>
						</ul>
					</section>
					<section><h4>Как?</h4></section>
					<section>
						<h4>Заменить импорт кода на динамические импорты (там, где это оправданно)</h4>
						<small>Динамические импорты позволят грузить небольшие чанки вместо огромных бандлов</small>
						<ul>
							<li>Меньше нагрузка на сеть</li>
							<li>Быстрее парсинг и компиляция</li>
							<li>Стандартные динамические импорты сильно более понятны чем кастомные резолверы</li>
							<li>Несколько чанков можно грузить параллельно, что позволит загружать их быстрее</li>
						</ul>
					</section>
					<section>
						<h4>Перейти на использование Module federation</h4>
						<small>Module Federation имеют все плюсы динамических импортов</small>
						<ul>
							<li>особенно актуально для viewer + a365</li>
							<li>viever фактически является bidirectional модулем (может работать как standalone, так и remote)</li>
							<li>плагины (которые живут сейчас во Viewer) - отдельные remote</li>
						</ul>
					</section>
					<section>
						<h4>Перейти на использование Module federation</h4>
						<ul>
							<li>динамическая загрузка</li>
							<li>простота встройки</li>
							<li>эффективное переиспользование кода между Viewer и A365</li>
						</ul>
					</section>
					<section>
						<h4>убрать лишний слой (iframe), вместо это упаковывать в iframe отдельные плагины</h4>
						<ul>
							<li>Упростит коммуникацию между viewer и a365</li>
							<li>Добавит изоляцию там где она нужна (в случае если она нужна)</li>
						</ul>
					</section>
					<section>
						<h4>Перейти на использование Vue v3</h4>
						<ul>
							<li>меньше потребление памяти за счет proxy</li>
							<li>лучше change detection</li>
							<li>простая работа с типизацией</li>
							<li>типизация шаблонов</li>
							<li>возможность получать дальнейшие улучшения функционала (__примеры__)</li>
							<li>static tree hoisting</li>
							<li>для перехода можно использову codemod и compat mode</li>
						</ul>
					</section>
				</section>
				<section>
					<section><h4>Дальнейшие шаги</h4></section>
					<section>
						<ul>
							<li>Пакет для eslint-config</li>
							<li>Разделяемые части webpack конфига</li>
							<li>Типизация для A365</li>
							<li>Тестовая инфраструктура</li>
							<li>Регулярные обновления пакетов</li>
							<li>Global UI team</li>
							<li>Static Code Analyse (хотя бы SonarLint для начала)</li>
							<li>Контроль Code quality</li>
							<li>Контроль Bundle size</li>
							<li>Регулярные bundle review</li>
						</ul>
					</section>
				</section>
				<section>
					<section><h4>Основные шаги</h4></section>
					<section>
						<ul>
							<li>
								Реструктурировать код
								<ul>
									<li>Собрать все в кучу</li>
									<li>Перенести документацию</li>
									<li>Для дальнейшего перехода на менеджер монорепозиториев</li>
								</ul>
							</li>
							<li>
								Перейти на менеджер монорепозиториев
								<ul>
									<li>Для удобства управления зависимостями</li>
									<li>Для удобства локальной линковки</li>
									<li>Для безопасности</li>
								</ul>
							</li>
							<li>
								Перейти на module federation
								<ul>
									<li>Для производительности</li>
									<li>Для дедупликации зависимостей</li>
									<li>Для выноса плагинов наружу из вьювера</li>
								</ul>
							</li>
							<li>
								Принять процессы
								<ul><li>Для добавления новых пакетов</li></ul>
							</li>
						</ul>
					</section>
				</section>
				<section>
					<h4>Общие результаты</h4>
					<ul>
						<li>Производительность</li>
						<li>Упрощение онбординга</li>
						<li>Безопасность</li>
					</ul>
				</section>
				<section>
					<h4>Общие риски</h4>
					<ul>
						<li>Естественное сопротивление всему новому может породить длительные дискуссии<br>Время и нервы потраченные на дискуссии может сократить количество пользы</li>
						<li>При переносе чего-либо куда-либо важно отследить, что бы git именно перенес файл, и не потерял историю изменений</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
